---
title: JIT Compiler
description: JIT Compiler
tags:
  - JIT_Compiler
date: 2023-02-13 03:25:19
---

# 중간 언어 (IR)

- 고급 언어와 기계어 사이의 언어
- **하드웨어가 아닌 가상 컴퓨터**에서 돌아가는 실행 프로그램을 위한 이진 표현법 → 보통 기계어보다 더 추상적
- `인터프리터`의 확장성을 위해 만들어짐
- `바이트 코드`를 사용하여 **하드웨어의 의존성을 줄임**

![250108-115239](/mdx/jit-compiler/250108-115239.png)

- 중간 언어를 사용하지 않는다면 왼쪽 그림처럼 각각의 하드웨어에 적합한 모든 컴파일링을 진행하여햐 함
- 중간 언어를 사용할 경우 오른쪽 그림처럼 다른 언어에 대한 컴파일러 B를 새롭게 개발하는 상황이 왔을 때
  이 과정에서 사용한 **중간 단계 언어 번역기를 그대로 사용**할 수 있다는 장점이 있음

# JIT 컴파일러 (Just-In-Time Compiler)

![250108-115310](/mdx/jit-compiler/250108-115310.png)

- 소스 코드를 파싱하여 `중간 언어 (IR)`인 `바이트 코드` 형태로 변환
  → `인터프리터 모드`라면 `바이트 코드`를 하나씩 읽어가며 동작 수행 / `JIT 모드`라면 생성된 `바이트 코드`를 기반으로 `네이티브 코드`로 컴파일하여 수행

<aside>
📌 JIT 컴파일러는 **`컴파일러`와 `인터프리터`의 장점을 합치고자 만들어진 개념**이다.
중간 언어라는 이름답게 프로그래밍 언어보다 더욱 컴퓨터에 가까운 언어이다.
이는 **실행과 동시에 즉각적인 컴파일을 가능**하게 만든 계기가 되었는데,
일반 프로그래밍 코드를 기계어로 컴파일하는 것보다 **컴파일 시간이 획기적으로 단축**되었기 때문이다.

</aside>

# JITC vs Compiler vs Interpreter

### 생산성 : 동적 컴파일러 (JITC) = 인터프리터 > 정적 컴파일러

### 성능 : 정적 컴파일러 > 동적 컴파일러 (JITC) > 인터프리터

- `JITC`, `인터프리터` : **동적인 환경에서 실행** → `컴파일` 도중 **최적화**할 시간이 `정적 컴파일러`에 비해 상대적으로 짧음
- 그럼에도 `네이티브 코드`의 실행 속도는 `바이트 코드`에 비해 훨씬 빠르기 때문에 `인터프리터`보다는 `JITC`가 훨씬 빠름

<aside>
💡 **하지만 JavaScript Engine에서는 상황이 다르다!**

</aside>

# JITC in JS Engine

> **`JavaScript Engine`에서의 `JITC`는 실행 성능이 `인터프리터`와 별반 차이가 없거나 오히려 더 느릴 수 있다.**

### 1. JavaScript는 **동적 타입의 언어**

- JS Engine에서의 `JITC`는 컴파일 시 **동적 타입에서의 모든 예외적인 케이스**를 다 고려하여 `네이티브 코드`를 생성해야 함
- 이는 매우 불필요한 과정이므로 JITC는 네이티브 코드를 생성하기보다 `slow case`로 코드를 넘거버림
  {' '}
  <aside>
    📌 `slow case`는 위와 같이 네이티브 코드로 생성하기에 비효율적인 동작들을
    엔진 내부에 구현되어있던 `function`을 호출해 동작을 수행하는 기관인데, 쉽게
    말하면 **바이트 코드를 네이티브 코드로 컴파일링 하지 않고 바로
    `인터프리팅`하는 기관**이다.
  </aside>
- **문제점** : 네이티브 코드를 컴파일하는 과정보다 그냥 `slow case`의 `인터프리터`가 동작하는 비중이 훨씬 높음 → **그냥 `인터프리터`와 별반 차이가 없어짐**
  추가로 `JITC`는 인터프리터와는 다르게 네이티브 코드로 컴파일 시 **`compilation overhead (컴파일로 인한 과부화)`** 가 발생하기 때문에 JS Engine에서는 꽤나 비효율적임

### 2. 초기 Javascript의 한계성

- 초창기 `Javascript`는 단순히 웹 페이지 요소들의 레이아웃을 건드리거나 간단한 반응형 환경을 만들기 위한 언어 → `JavaScript`는 `JAVA`보다 `Hot Spot`이 적었음
  {' '}
  <aside>
    📌 **`Hot Spot`** : ‘자주 반복돼서 수행되는 구간’, 즉 **최적화의 필요성이
    높은 부분**을 뜻함
  </aside>
- Hot spot이 적다는 것은 **_네이티브 코드로의 최적화 컴파일이 과연 필요한가?_** 라는 의문을 낳게 됨
  (어차피 최적화할 부분이 적다면 굳이 네이티브 코드로의 컴파일을 위한 compilation overhead를 감내할 필요가 있나?)

> 하지만 대다수의 JS Engine이 인터프리터 방식이 아니라 **JITC 방식을 사용**한 이유는, HTML과 JS가 점점 진화하며 복잡한 연산이나 반복 연산을 포함하는 JavaScript 코드도 점점 늘었기 때문이다.

**그러나 결국 JavaScript JITC도 JavaScript 환경에 맞게 개선되어야함에는 틀림없었다.**

>

# AJITC (Adaptive-Just-In-Time Compiler)

- 실행하는 `JavaScript` 코드에 적응하는 `JIT 컴파일러`
- 현재 대부분의 브라우저 엔진이 사용하는 방식
- **V8 엔진**이 대표적
- 모든 바이트 코드를 네이티브 코드로 컴파일하지 않고 프로파일링을 통해 **최적화할 코드를 선별한 후 해당 코드들만 컴파일**함
  **⇒ compilation overhead 최소화, Hot spot 해결**
